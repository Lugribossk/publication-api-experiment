<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">/*global console*/
define([&quot;jquery&quot;, &quot;util/Promise&quot;, &quot;util/ES5&quot;],
    function ($, Promise, ES5) { // ES5 only to force it being loaded before its functionality is required, as this class is one of the earliest loaded.
        &quot;use strict&quot;;

        var output;

        // Create a dummy console for IE.
        if (console !== undefined) {
            output = console;
        } else {
            output = {
                info: function () {},
                warn: function () {},
                error: function () {}
            };
        }

<span id='Logger-method-constructor'><span id='Logger'>        /**
</span></span>         * A simple instantiable logger.
         *
         * @author Bo Gotthardt
         * @constructor
         *
         * @param {String} name The logger name.
         */
        function Logger(name) {
            this._name = name;
        }

<span id='Logger-method-_callPrintFunction'>        /**
</span>         * Use the specified console function name to print the list of data.
         *
         * @private
         *
         * @param {String} functionName
         * @param {Arguments/ *[]} dataList
         */
        Logger.prototype._callPrintFunction = function (functionName, dataList) {
            // Chrome requires the console as it's own context.
            // IE doesn't inherit the logging functions from Function.
            var func = Function.prototype.bind.call(output[functionName], output);
            var messages = [&quot;[&quot; + this._name + &quot;]&quot;].concat($.makeArray(dataList));
            func.apply(output, messages);
        };

<span id='Logger-method-_print'>        /**
</span>         * Print the list of data to the console.
         * If there is only one argument and it is a Promise, it's resolved value will be logged instead.
         *
         * @private
         *
         * @param {String} functionName
         * @param {Arguments} dataList
         */
        Logger.prototype._print = function (functionName, dataList) {
            var scope = this;
            if (Promise.isPromise(dataList[0]) &amp;&amp; dataList.length === 1) {
                dataList[0]
                    .done(function () {
                        scope._callPrintFunction(functionName, arguments);
                    })
                    .fail(function () {
                        scope._callPrintFunction(functionName, [&quot;Promise failed.&quot;]);
                    });
            } else {
                scope._callPrintFunction(functionName, dataList);
            }

        };

<span id='Logger-method-info'>        /**
</span>         * Log informational message.
         */
        Logger.prototype.info = function () {
            this._print(&quot;info&quot;, arguments);
        };

<span id='Logger-method-warn'>        /**
</span>         * Log warning about undesired behavior.
         */
        Logger.prototype.warn = function () {
            this._print(&quot;warn&quot;, arguments);
        };

<span id='Logger-method-error'>        /**
</span>         * Log error message.
         */
        Logger.prototype.error = function () {
            this._print(&quot;error&quot;, arguments);
        };

<span id='Logger-method-assert'>        /**
</span>         * Assert that the specified condition is true. If it is not, any additional arguments will be logged as an
         * error and the browser debugger will be triggered.
         *
         * @param {*} condition The condition to check
         */
        Logger.prototype.assert = function (condition) {
            if (!condition) {
                this.error.apply(this, $.makeArray(arguments).slice(1));
                // This debugger statement is allowed to stay in as it's part of the assert functionality.
                /*jslint debug:true*/
                debugger;
            }
        };

        return Logger;
    });</pre>
</body>
</html>
